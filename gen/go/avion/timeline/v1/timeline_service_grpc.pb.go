// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: avion/timeline/v1/timeline_service.proto

package timelinev1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	TimelineService_GetHomeTimeline_FullMethodName         = "/avion.timeline.v1.TimelineService/GetHomeTimeline"
	TimelineService_GetUserTimeline_FullMethodName         = "/avion.timeline.v1.TimelineService/GetUserTimeline"
	TimelineService_GetPublicTimeline_FullMethodName       = "/avion.timeline.v1.TimelineService/GetPublicTimeline"
	TimelineService_GetListTimeline_FullMethodName         = "/avion.timeline.v1.TimelineService/GetListTimeline"
	TimelineService_GetHashtagTimeline_FullMethodName      = "/avion.timeline.v1.TimelineService/GetHashtagTimeline"
	TimelineService_AddToTimeline_FullMethodName           = "/avion.timeline.v1.TimelineService/AddToTimeline"
	TimelineService_RemoveFromTimeline_FullMethodName      = "/avion.timeline.v1.TimelineService/RemoveFromTimeline"
	TimelineService_MarkAsRead_FullMethodName              = "/avion.timeline.v1.TimelineService/MarkAsRead"
	TimelineService_GetTimelineStatistics_FullMethodName   = "/avion.timeline.v1.TimelineService/GetTimelineStatistics"
	TimelineService_GetTimelineSettings_FullMethodName     = "/avion.timeline.v1.TimelineService/GetTimelineSettings"
	TimelineService_UpdateTimelineSettings_FullMethodName  = "/avion.timeline.v1.TimelineService/UpdateTimelineSettings"
	TimelineService_BatchAddToTimeline_FullMethodName      = "/avion.timeline.v1.TimelineService/BatchAddToTimeline"
	TimelineService_ClearTimeline_FullMethodName           = "/avion.timeline.v1.TimelineService/ClearTimeline"
	TimelineService_RebuildTimeline_FullMethodName         = "/avion.timeline.v1.TimelineService/RebuildTimeline"
	TimelineService_StreamTimelineUpdates_FullMethodName   = "/avion.timeline.v1.TimelineService/StreamTimelineUpdates"
	TimelineService_StreamMultipleTimelines_FullMethodName = "/avion.timeline.v1.TimelineService/StreamMultipleTimelines"
)

// TimelineServiceClient is the client API for TimelineService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// タイムラインサービス
type TimelineServiceClient interface {
	// ホームタイムラインを取得
	GetHomeTimeline(ctx context.Context, in *GetHomeTimelineRequest, opts ...grpc.CallOption) (*GetHomeTimelineResponse, error)
	// ユーザータイムラインを取得
	GetUserTimeline(ctx context.Context, in *GetUserTimelineRequest, opts ...grpc.CallOption) (*GetUserTimelineResponse, error)
	// パブリックタイムラインを取得
	GetPublicTimeline(ctx context.Context, in *GetPublicTimelineRequest, opts ...grpc.CallOption) (*GetPublicTimelineResponse, error)
	// リストタイムラインを取得
	GetListTimeline(ctx context.Context, in *GetListTimelineRequest, opts ...grpc.CallOption) (*GetListTimelineResponse, error)
	// ハッシュタグタイムラインを取得
	GetHashtagTimeline(ctx context.Context, in *GetHashtagTimelineRequest, opts ...grpc.CallOption) (*GetHashtagTimelineResponse, error)
	// タイムラインに追加
	AddToTimeline(ctx context.Context, in *AddToTimelineRequest, opts ...grpc.CallOption) (*AddToTimelineResponse, error)
	// タイムラインから削除
	RemoveFromTimeline(ctx context.Context, in *RemoveFromTimelineRequest, opts ...grpc.CallOption) (*RemoveFromTimelineResponse, error)
	// 既読マーク
	MarkAsRead(ctx context.Context, in *MarkAsReadRequest, opts ...grpc.CallOption) (*MarkAsReadResponse, error)
	// タイムライン統計情報を取得
	GetTimelineStatistics(ctx context.Context, in *GetTimelineStatisticsRequest, opts ...grpc.CallOption) (*GetTimelineStatisticsResponse, error)
	// タイムライン設定を取得
	GetTimelineSettings(ctx context.Context, in *GetTimelineSettingsRequest, opts ...grpc.CallOption) (*GetTimelineSettingsResponse, error)
	// タイムライン設定を更新
	UpdateTimelineSettings(ctx context.Context, in *UpdateTimelineSettingsRequest, opts ...grpc.CallOption) (*UpdateTimelineSettingsResponse, error)
	// バッチでタイムラインに追加（内部用）
	BatchAddToTimeline(ctx context.Context, in *BatchAddToTimelineRequest, opts ...grpc.CallOption) (*BatchAddToTimelineResponse, error)
	// タイムラインをクリア
	ClearTimeline(ctx context.Context, in *ClearTimelineRequest, opts ...grpc.CallOption) (*ClearTimelineResponse, error)
	// タイムラインを再構築（内部用）
	RebuildTimeline(ctx context.Context, in *RebuildTimelineRequest, opts ...grpc.CallOption) (*RebuildTimelineResponse, error)
	// リアルタイムタイムライン更新のストリーミング
	StreamTimelineUpdates(ctx context.Context, in *StreamTimelineUpdatesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamTimelineUpdatesResponse], error)
	// 複数タイムラインの同時ストリーミング
	StreamMultipleTimelines(ctx context.Context, in *StreamMultipleTimelinesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamMultipleTimelinesResponse], error)
}

type timelineServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTimelineServiceClient(cc grpc.ClientConnInterface) TimelineServiceClient {
	return &timelineServiceClient{cc}
}

func (c *timelineServiceClient) GetHomeTimeline(ctx context.Context, in *GetHomeTimelineRequest, opts ...grpc.CallOption) (*GetHomeTimelineResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetHomeTimelineResponse)
	err := c.cc.Invoke(ctx, TimelineService_GetHomeTimeline_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *timelineServiceClient) GetUserTimeline(ctx context.Context, in *GetUserTimelineRequest, opts ...grpc.CallOption) (*GetUserTimelineResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserTimelineResponse)
	err := c.cc.Invoke(ctx, TimelineService_GetUserTimeline_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *timelineServiceClient) GetPublicTimeline(ctx context.Context, in *GetPublicTimelineRequest, opts ...grpc.CallOption) (*GetPublicTimelineResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPublicTimelineResponse)
	err := c.cc.Invoke(ctx, TimelineService_GetPublicTimeline_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *timelineServiceClient) GetListTimeline(ctx context.Context, in *GetListTimelineRequest, opts ...grpc.CallOption) (*GetListTimelineResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetListTimelineResponse)
	err := c.cc.Invoke(ctx, TimelineService_GetListTimeline_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *timelineServiceClient) GetHashtagTimeline(ctx context.Context, in *GetHashtagTimelineRequest, opts ...grpc.CallOption) (*GetHashtagTimelineResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetHashtagTimelineResponse)
	err := c.cc.Invoke(ctx, TimelineService_GetHashtagTimeline_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *timelineServiceClient) AddToTimeline(ctx context.Context, in *AddToTimelineRequest, opts ...grpc.CallOption) (*AddToTimelineResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddToTimelineResponse)
	err := c.cc.Invoke(ctx, TimelineService_AddToTimeline_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *timelineServiceClient) RemoveFromTimeline(ctx context.Context, in *RemoveFromTimelineRequest, opts ...grpc.CallOption) (*RemoveFromTimelineResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemoveFromTimelineResponse)
	err := c.cc.Invoke(ctx, TimelineService_RemoveFromTimeline_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *timelineServiceClient) MarkAsRead(ctx context.Context, in *MarkAsReadRequest, opts ...grpc.CallOption) (*MarkAsReadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MarkAsReadResponse)
	err := c.cc.Invoke(ctx, TimelineService_MarkAsRead_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *timelineServiceClient) GetTimelineStatistics(ctx context.Context, in *GetTimelineStatisticsRequest, opts ...grpc.CallOption) (*GetTimelineStatisticsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTimelineStatisticsResponse)
	err := c.cc.Invoke(ctx, TimelineService_GetTimelineStatistics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *timelineServiceClient) GetTimelineSettings(ctx context.Context, in *GetTimelineSettingsRequest, opts ...grpc.CallOption) (*GetTimelineSettingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTimelineSettingsResponse)
	err := c.cc.Invoke(ctx, TimelineService_GetTimelineSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *timelineServiceClient) UpdateTimelineSettings(ctx context.Context, in *UpdateTimelineSettingsRequest, opts ...grpc.CallOption) (*UpdateTimelineSettingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateTimelineSettingsResponse)
	err := c.cc.Invoke(ctx, TimelineService_UpdateTimelineSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *timelineServiceClient) BatchAddToTimeline(ctx context.Context, in *BatchAddToTimelineRequest, opts ...grpc.CallOption) (*BatchAddToTimelineResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BatchAddToTimelineResponse)
	err := c.cc.Invoke(ctx, TimelineService_BatchAddToTimeline_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *timelineServiceClient) ClearTimeline(ctx context.Context, in *ClearTimelineRequest, opts ...grpc.CallOption) (*ClearTimelineResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClearTimelineResponse)
	err := c.cc.Invoke(ctx, TimelineService_ClearTimeline_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *timelineServiceClient) RebuildTimeline(ctx context.Context, in *RebuildTimelineRequest, opts ...grpc.CallOption) (*RebuildTimelineResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RebuildTimelineResponse)
	err := c.cc.Invoke(ctx, TimelineService_RebuildTimeline_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *timelineServiceClient) StreamTimelineUpdates(ctx context.Context, in *StreamTimelineUpdatesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamTimelineUpdatesResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &TimelineService_ServiceDesc.Streams[0], TimelineService_StreamTimelineUpdates_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamTimelineUpdatesRequest, StreamTimelineUpdatesResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type TimelineService_StreamTimelineUpdatesClient = grpc.ServerStreamingClient[StreamTimelineUpdatesResponse]

func (c *timelineServiceClient) StreamMultipleTimelines(ctx context.Context, in *StreamMultipleTimelinesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamMultipleTimelinesResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &TimelineService_ServiceDesc.Streams[1], TimelineService_StreamMultipleTimelines_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamMultipleTimelinesRequest, StreamMultipleTimelinesResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type TimelineService_StreamMultipleTimelinesClient = grpc.ServerStreamingClient[StreamMultipleTimelinesResponse]

// TimelineServiceServer is the server API for TimelineService service.
// All implementations must embed UnimplementedTimelineServiceServer
// for forward compatibility.
//
// タイムラインサービス
type TimelineServiceServer interface {
	// ホームタイムラインを取得
	GetHomeTimeline(context.Context, *GetHomeTimelineRequest) (*GetHomeTimelineResponse, error)
	// ユーザータイムラインを取得
	GetUserTimeline(context.Context, *GetUserTimelineRequest) (*GetUserTimelineResponse, error)
	// パブリックタイムラインを取得
	GetPublicTimeline(context.Context, *GetPublicTimelineRequest) (*GetPublicTimelineResponse, error)
	// リストタイムラインを取得
	GetListTimeline(context.Context, *GetListTimelineRequest) (*GetListTimelineResponse, error)
	// ハッシュタグタイムラインを取得
	GetHashtagTimeline(context.Context, *GetHashtagTimelineRequest) (*GetHashtagTimelineResponse, error)
	// タイムラインに追加
	AddToTimeline(context.Context, *AddToTimelineRequest) (*AddToTimelineResponse, error)
	// タイムラインから削除
	RemoveFromTimeline(context.Context, *RemoveFromTimelineRequest) (*RemoveFromTimelineResponse, error)
	// 既読マーク
	MarkAsRead(context.Context, *MarkAsReadRequest) (*MarkAsReadResponse, error)
	// タイムライン統計情報を取得
	GetTimelineStatistics(context.Context, *GetTimelineStatisticsRequest) (*GetTimelineStatisticsResponse, error)
	// タイムライン設定を取得
	GetTimelineSettings(context.Context, *GetTimelineSettingsRequest) (*GetTimelineSettingsResponse, error)
	// タイムライン設定を更新
	UpdateTimelineSettings(context.Context, *UpdateTimelineSettingsRequest) (*UpdateTimelineSettingsResponse, error)
	// バッチでタイムラインに追加（内部用）
	BatchAddToTimeline(context.Context, *BatchAddToTimelineRequest) (*BatchAddToTimelineResponse, error)
	// タイムラインをクリア
	ClearTimeline(context.Context, *ClearTimelineRequest) (*ClearTimelineResponse, error)
	// タイムラインを再構築（内部用）
	RebuildTimeline(context.Context, *RebuildTimelineRequest) (*RebuildTimelineResponse, error)
	// リアルタイムタイムライン更新のストリーミング
	StreamTimelineUpdates(*StreamTimelineUpdatesRequest, grpc.ServerStreamingServer[StreamTimelineUpdatesResponse]) error
	// 複数タイムラインの同時ストリーミング
	StreamMultipleTimelines(*StreamMultipleTimelinesRequest, grpc.ServerStreamingServer[StreamMultipleTimelinesResponse]) error
	mustEmbedUnimplementedTimelineServiceServer()
}

// UnimplementedTimelineServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTimelineServiceServer struct{}

func (UnimplementedTimelineServiceServer) GetHomeTimeline(context.Context, *GetHomeTimelineRequest) (*GetHomeTimelineResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHomeTimeline not implemented")
}
func (UnimplementedTimelineServiceServer) GetUserTimeline(context.Context, *GetUserTimelineRequest) (*GetUserTimelineResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserTimeline not implemented")
}
func (UnimplementedTimelineServiceServer) GetPublicTimeline(context.Context, *GetPublicTimelineRequest) (*GetPublicTimelineResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPublicTimeline not implemented")
}
func (UnimplementedTimelineServiceServer) GetListTimeline(context.Context, *GetListTimelineRequest) (*GetListTimelineResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetListTimeline not implemented")
}
func (UnimplementedTimelineServiceServer) GetHashtagTimeline(context.Context, *GetHashtagTimelineRequest) (*GetHashtagTimelineResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHashtagTimeline not implemented")
}
func (UnimplementedTimelineServiceServer) AddToTimeline(context.Context, *AddToTimelineRequest) (*AddToTimelineResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddToTimeline not implemented")
}
func (UnimplementedTimelineServiceServer) RemoveFromTimeline(context.Context, *RemoveFromTimelineRequest) (*RemoveFromTimelineResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveFromTimeline not implemented")
}
func (UnimplementedTimelineServiceServer) MarkAsRead(context.Context, *MarkAsReadRequest) (*MarkAsReadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarkAsRead not implemented")
}
func (UnimplementedTimelineServiceServer) GetTimelineStatistics(context.Context, *GetTimelineStatisticsRequest) (*GetTimelineStatisticsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTimelineStatistics not implemented")
}
func (UnimplementedTimelineServiceServer) GetTimelineSettings(context.Context, *GetTimelineSettingsRequest) (*GetTimelineSettingsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTimelineSettings not implemented")
}
func (UnimplementedTimelineServiceServer) UpdateTimelineSettings(context.Context, *UpdateTimelineSettingsRequest) (*UpdateTimelineSettingsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTimelineSettings not implemented")
}
func (UnimplementedTimelineServiceServer) BatchAddToTimeline(context.Context, *BatchAddToTimelineRequest) (*BatchAddToTimelineResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchAddToTimeline not implemented")
}
func (UnimplementedTimelineServiceServer) ClearTimeline(context.Context, *ClearTimelineRequest) (*ClearTimelineResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClearTimeline not implemented")
}
func (UnimplementedTimelineServiceServer) RebuildTimeline(context.Context, *RebuildTimelineRequest) (*RebuildTimelineResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RebuildTimeline not implemented")
}
func (UnimplementedTimelineServiceServer) StreamTimelineUpdates(*StreamTimelineUpdatesRequest, grpc.ServerStreamingServer[StreamTimelineUpdatesResponse]) error {
	return status.Errorf(codes.Unimplemented, "method StreamTimelineUpdates not implemented")
}
func (UnimplementedTimelineServiceServer) StreamMultipleTimelines(*StreamMultipleTimelinesRequest, grpc.ServerStreamingServer[StreamMultipleTimelinesResponse]) error {
	return status.Errorf(codes.Unimplemented, "method StreamMultipleTimelines not implemented")
}
func (UnimplementedTimelineServiceServer) mustEmbedUnimplementedTimelineServiceServer() {}
func (UnimplementedTimelineServiceServer) testEmbeddedByValue()                         {}

// UnsafeTimelineServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TimelineServiceServer will
// result in compilation errors.
type UnsafeTimelineServiceServer interface {
	mustEmbedUnimplementedTimelineServiceServer()
}

func RegisterTimelineServiceServer(s grpc.ServiceRegistrar, srv TimelineServiceServer) {
	// If the following call pancis, it indicates UnimplementedTimelineServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TimelineService_ServiceDesc, srv)
}

func _TimelineService_GetHomeTimeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHomeTimelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimelineServiceServer).GetHomeTimeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TimelineService_GetHomeTimeline_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimelineServiceServer).GetHomeTimeline(ctx, req.(*GetHomeTimelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TimelineService_GetUserTimeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserTimelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimelineServiceServer).GetUserTimeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TimelineService_GetUserTimeline_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimelineServiceServer).GetUserTimeline(ctx, req.(*GetUserTimelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TimelineService_GetPublicTimeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPublicTimelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimelineServiceServer).GetPublicTimeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TimelineService_GetPublicTimeline_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimelineServiceServer).GetPublicTimeline(ctx, req.(*GetPublicTimelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TimelineService_GetListTimeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetListTimelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimelineServiceServer).GetListTimeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TimelineService_GetListTimeline_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimelineServiceServer).GetListTimeline(ctx, req.(*GetListTimelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TimelineService_GetHashtagTimeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHashtagTimelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimelineServiceServer).GetHashtagTimeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TimelineService_GetHashtagTimeline_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimelineServiceServer).GetHashtagTimeline(ctx, req.(*GetHashtagTimelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TimelineService_AddToTimeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddToTimelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimelineServiceServer).AddToTimeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TimelineService_AddToTimeline_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimelineServiceServer).AddToTimeline(ctx, req.(*AddToTimelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TimelineService_RemoveFromTimeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveFromTimelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimelineServiceServer).RemoveFromTimeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TimelineService_RemoveFromTimeline_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimelineServiceServer).RemoveFromTimeline(ctx, req.(*RemoveFromTimelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TimelineService_MarkAsRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkAsReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimelineServiceServer).MarkAsRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TimelineService_MarkAsRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimelineServiceServer).MarkAsRead(ctx, req.(*MarkAsReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TimelineService_GetTimelineStatistics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTimelineStatisticsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimelineServiceServer).GetTimelineStatistics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TimelineService_GetTimelineStatistics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimelineServiceServer).GetTimelineStatistics(ctx, req.(*GetTimelineStatisticsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TimelineService_GetTimelineSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTimelineSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimelineServiceServer).GetTimelineSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TimelineService_GetTimelineSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimelineServiceServer).GetTimelineSettings(ctx, req.(*GetTimelineSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TimelineService_UpdateTimelineSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTimelineSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimelineServiceServer).UpdateTimelineSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TimelineService_UpdateTimelineSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimelineServiceServer).UpdateTimelineSettings(ctx, req.(*UpdateTimelineSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TimelineService_BatchAddToTimeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchAddToTimelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimelineServiceServer).BatchAddToTimeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TimelineService_BatchAddToTimeline_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimelineServiceServer).BatchAddToTimeline(ctx, req.(*BatchAddToTimelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TimelineService_ClearTimeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearTimelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimelineServiceServer).ClearTimeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TimelineService_ClearTimeline_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimelineServiceServer).ClearTimeline(ctx, req.(*ClearTimelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TimelineService_RebuildTimeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RebuildTimelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TimelineServiceServer).RebuildTimeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TimelineService_RebuildTimeline_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TimelineServiceServer).RebuildTimeline(ctx, req.(*RebuildTimelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TimelineService_StreamTimelineUpdates_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamTimelineUpdatesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TimelineServiceServer).StreamTimelineUpdates(m, &grpc.GenericServerStream[StreamTimelineUpdatesRequest, StreamTimelineUpdatesResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type TimelineService_StreamTimelineUpdatesServer = grpc.ServerStreamingServer[StreamTimelineUpdatesResponse]

func _TimelineService_StreamMultipleTimelines_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamMultipleTimelinesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TimelineServiceServer).StreamMultipleTimelines(m, &grpc.GenericServerStream[StreamMultipleTimelinesRequest, StreamMultipleTimelinesResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type TimelineService_StreamMultipleTimelinesServer = grpc.ServerStreamingServer[StreamMultipleTimelinesResponse]

// TimelineService_ServiceDesc is the grpc.ServiceDesc for TimelineService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TimelineService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "avion.timeline.v1.TimelineService",
	HandlerType: (*TimelineServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetHomeTimeline",
			Handler:    _TimelineService_GetHomeTimeline_Handler,
		},
		{
			MethodName: "GetUserTimeline",
			Handler:    _TimelineService_GetUserTimeline_Handler,
		},
		{
			MethodName: "GetPublicTimeline",
			Handler:    _TimelineService_GetPublicTimeline_Handler,
		},
		{
			MethodName: "GetListTimeline",
			Handler:    _TimelineService_GetListTimeline_Handler,
		},
		{
			MethodName: "GetHashtagTimeline",
			Handler:    _TimelineService_GetHashtagTimeline_Handler,
		},
		{
			MethodName: "AddToTimeline",
			Handler:    _TimelineService_AddToTimeline_Handler,
		},
		{
			MethodName: "RemoveFromTimeline",
			Handler:    _TimelineService_RemoveFromTimeline_Handler,
		},
		{
			MethodName: "MarkAsRead",
			Handler:    _TimelineService_MarkAsRead_Handler,
		},
		{
			MethodName: "GetTimelineStatistics",
			Handler:    _TimelineService_GetTimelineStatistics_Handler,
		},
		{
			MethodName: "GetTimelineSettings",
			Handler:    _TimelineService_GetTimelineSettings_Handler,
		},
		{
			MethodName: "UpdateTimelineSettings",
			Handler:    _TimelineService_UpdateTimelineSettings_Handler,
		},
		{
			MethodName: "BatchAddToTimeline",
			Handler:    _TimelineService_BatchAddToTimeline_Handler,
		},
		{
			MethodName: "ClearTimeline",
			Handler:    _TimelineService_ClearTimeline_Handler,
		},
		{
			MethodName: "RebuildTimeline",
			Handler:    _TimelineService_RebuildTimeline_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamTimelineUpdates",
			Handler:       _TimelineService_StreamTimelineUpdates_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamMultipleTimelines",
			Handler:       _TimelineService_StreamMultipleTimelines_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "avion/timeline/v1/timeline_service.proto",
}
