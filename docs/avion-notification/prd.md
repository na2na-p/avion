# PRD: avion-notification

## 概要

Avionにおけるユーザーへの通知（メンション、フォロー、リアクション、リポストなど）を生成、管理、および配信する機能を提供するマイクロサービスを実装する。

## 背景

SNSにおいて、ユーザーが自身に関連する重要なイベント（誰かにフォローされた、自分の投稿にリアクションが付いた、メンションされたなど）を適時に知ることは、エンゲージメントを維持し、コミュニケーションを促進する上で不可欠である。これらの通知イベントを集約し、ユーザーごとに管理・配信する専門のマイクロサービスを設けることで、通知ロジックを他のサービスから分離し、効率的な通知システムを構築する。

## Scientific Merits

*   **ユーザーエンゲージメント向上:** 自分宛ての活動を通知することで、ユーザーのサービスへの再訪を促し、インタラクションを活性化させる。
*   **関心の分離:** 通知生成という横断的な関心事を一元管理することで、各イベント発生元サービス（Post, User, Reactionなど）の責務を単純化できる。
*   **スケーラビリティ:** 通知の生成・配信量はユーザー数やアクティビティ量に比例して増加するため、独立したサービスとしてスケールさせることが有効。
*   **柔軟な配信:** 将来的にプッシュ通知やメール通知など、多様な通知チャネルを追加する際に、変更箇所を本サービスに集約できる。

通知はユーザー体験の質に直接影響する重要な機能であり、その生成と配信を効率的かつ確実に行うための専門サービスは価値が高い。

## Design Doc

後で書く

## 参考ドキュメント

*   [Avion アーキテクチャ概要](./../architecture.md)

## 製品原則

*   **関連性の高い通知:** ユーザーにとって意味のある、自身に関連するイベントのみを通知する。
*   **タイムリーな配信:** イベント発生から可能な限り短い遅延で通知を届ける。
*   **明確な情報:** 何に関する通知なのか（誰が何をしたか）を分かりやすく伝える。
*   **管理可能な通知:** ユーザーが通知を確認し、既読状態を管理できるようにする。

## やること/やらないこと

### やること

*   各種イベント（フォローされた、メンションされた、自分のDropにリアクションされた、自分のDropがリポストされたなど）に基づく通知データの生成。
*   生成された通知の永続化 (ユーザーごと)。
*   ユーザー向けの通知リスト取得APIの提供 (未読・既読、ページネーション付き)。
*   通知の既読状態管理 (個別既読、一括既読)。
*   未読通知件数の取得APIの提供。
*   Server-Sent Events (SSE) によるリアルタイム通知配信 (例: 新しい通知があることをクライアントに伝える)。
*   Web Pushによるプッシュ通知連携 (PWAを前提)。
*   (将来的に) 通知設定 (どの種類の通知を受け取るか)。

### やらないこと

*   **イベント発生元のビジネスロジック:** フォロー処理自体 (`avion-user`) やリアクション処理自体 (`avion-reaction`) は担当しない。イベントを受け取って通知を生成するのみ。
*   **通知内容の完全な詳細データ保持:** 通知にはイベントの概要と関連エンティティへの参照 (ユーザーID, Drop IDなど) を含めるが、Drop本文全文などを複製して保持することは避ける (必要に応じて関連サービスに問い合わせる)。
*   **複雑な通知グルーピング (初期):** 「Aさん、Bさん、他3人があなたの投稿にリアクションしました」のような高度なグルーピングは初期リリースでは必須としない。
*   **通知の優先度付け (初期):** 全ての通知を同等に扱う。
*   **メール通知:** 特にリアクションのような頻度の高いイベントについて、メールでの通知は行わない。他の種類の通知についても、現時点では実装しない。

## 対象ユーザ

*   Avion エンドユーザー (API Gateway経由)
*   Avion の他のマイクロサービス (イベント発行元として: User, Post, Reaction, ActivityPubなど)
*   Avion 開発者・運用者

## ユースケース

### 通知リストの表示

1.  ユーザーが通知タブ/ページを開く。
2.  フロントエンドは `avion-gateway` 経由で `avion-notification` に通知リスト取得リクエスト (認証JWT, ページネーション情報) を送信する。
3.  `avion-notification` はデータベースから該当ユーザーの通知を新しい順に取得し、返す。通知には種類 (フォロー, メンション, リアクション等)、関連ユーザー/Dropの情報、既読状態、タイムスタンプなどが含まれる。
4.  フロントエンドは受け取ったリストをもとに通知一覧を表示する。未読通知は区別して表示する。

(UIモック: 通知一覧画面)

### 未読通知件数の表示

1.  フロントエンドはアプリケーションのヘッダーなどに未読通知件数を表示する必要がある。
2.  フロントエンドは `avion-gateway` 経由で `avion-notification` に未読通知件数取得リクエスト (認証JWT) を送信する。
3.  `avion-notification` はデータベースから該当ユーザーの未読通知件数をカウントし、返す。
4.  フロントエンドは受け取った件数を表示する。

(UIモック: ヘッダーの通知アイコンとバッジ)

### 通知の既読化

1.  ユーザーが通知リストを開く、または特定の通知をクリック/タップする。
2.  フロントエンドは `avion-gateway` 経由で `avion-notification` に通知既読化リクエスト (認証JWT, 対象通知ID or 一括既読フラグ) を送信する。
3.  `avion-notification` はデータベースで該当通知の既読フラグを更新する。
4.  成功レスポンスを返す。
5.  フロントエンドは表示を更新し、未読件数も更新する。

### イベント発生と通知生成 (例: リアクション)

1.  ユーザーBがユーザーAのDropにリアクションする (`avion-reaction` が処理)。
2.  `avion-reaction` はリアクション成功後、通知生成に必要な情報 (リアクションしたユーザーBのID, リアクションされたDrop AのID, Drop作成者AのID, 絵文字コード) を含むイベントを発行する (例: Redis Pub/Sub)。
3.  `avion-notification` はイベントを受信する。
4.  `avion-notification` はイベント情報に基づき、ユーザーA向けのリアクション通知データを生成し、データベースに保存する。
5.  (将来的にWebSocketが有効な場合) ユーザーAの接続があれば、リアルタイムで通知を送信する。

## 機能要求

*   **通知種別:** フォロー、メンション、リアクション、リポストなど、主要なSNSイベントに対応する通知種別を定義すること。
*   **通知データ:** 各通知には、通知種別、イベント発生日時、関連するアクター (誰が)、関連するオブジェクト (どのDropに)、通知対象ユーザー、既読状態などの情報を含むこと。
*   **永続化:** 生成された通知はユーザーごとにデータベースに保存されること。
*   **既読管理:** 通知ごとに既読/未読の状態を管理できること。一括既読機能を提供すること。
*   **API:** 通知リスト取得 (ページネーション、未読/全件フィルタ)、未読件数取得、既読化のためのRESTful APIを提供すること。認証が必要なエンドポイントはJWTで保護すること。
*   **イベント受信:** 他のマイクロサービスから発行される通知トリガーとなるイベントを確実に受信できる仕組みを持つこと (メッセージキューなど)。

## 技術的要求

### レイテンシ

*   通知リスト取得 (1ページあたり): 平均 200ms 以下
*   未読件数取得: 平均 50ms 以下
*   既読化処理: 平均 100ms 以下
*   イベント受信から通知生成・保存まで: 非同期処理。数秒以内の遅延を目指す。

### 可用性

*   通知リスト取得、既読化API、SSE接続エンドポイント、Web Push送信機能は比較的高可用性が求められる。Kubernetes上での運用を前提とし、複数レプリカによる冗長構成をとる。
*   イベント受信と通知生成処理も、通知の遅延や欠損を防ぐために安定稼働が必要。

### スケーラビリティ

*   ユーザー数、アクティビティ量に応じて通知データが増加するため、データベースの書き込み・読み取り性能が重要。特に通知リスト取得クエリの最適化が必要。
*   イベント処理ワーカーをスケールアウト可能にすること。
*   (将来的にWebSocketを導入する場合) 多数の同時接続を処理できるスケーラビリティが必要。

### データ整合性

*   イベントの重複処理や処理漏れを防ぐ仕組み (メッセージキューの冪等性担保など)。
*   削除されたユーザーやDropに関連する通知の扱い (表示しない、削除するなど)。

### その他技術要件

*   **ステートレス:** サービス自体は状態を持たず、水平スケールが可能であること。SSE接続情報は別途管理が必要になる場合がある (Redis等を利用)。Web Pushのサブスクリプション情報はDBで管理する。
*   **Observability:** OpenTelemetry SDKを導入し、トレース・メトリクス・ログを出力可能にすること。イベント受信時にトレースを開始/継続し、他のサービスへの問い合わせや通知配信時にもコンテキストを伝播すること。
*   **リアルタイム/プッシュ:** Server-Sent Events (SSE) および Web Push プロトコルを実装する。

## 決まっていないこと

*   SSE接続の管理方法とスケーラビリティ対策。
*   SSEで送信するイベントの具体的なフォーマット (通知内容そのものか、更新通知か)。
*   Web PushのVAPIDキー管理方法。
*   通知設定機能の詳細な仕様。
*   通知データの保存期間とアーカイブ/削除ポリシー。
*   通知グルーピングの実装方法 (将来的に実装する場合)。
*   使用するメッセージキューシステムの選定。
