# PRD: avion-timeline

## 概要

Avionにおける各種タイムライン（ホーム、ローカル、グローバル）の生成および取得機能を提供するマイクロサービスを実装する。

## 背景

SNSの主要な体験として、ユーザーは自身がフォローしているユーザーの投稿（ホームタイムライン）、自身が所属するサーバー内の公開投稿（ローカルタイムライン）、および連合しているサーバーを含む広範囲の公開投稿（グローバルタイムライン、または連合タイムライン）を時系列などで閲覧したい。これらのタイムラインを効率的に生成し、高速に提供するための専用サービスが必要となる。特にホームタイムラインはユーザーごとにパーソナライズされるため、スケーラブルな設計が求められる。

## Scientific Merits

*   **パフォーマンス:** タイムライン生成ロジックを集約し、Redisなどのキャッシュを積極的に活用することで、タイムライン取得APIのレスポンスタイムを短縮できる。特に読み取り頻度が高いホームタイムラインにおいて効果が大きい。
*   **スケーラビリティ:** タイムライン生成・取得の負荷を他のサービスから分離し、`avion-timeline` サービスを独立してスケールさせることが可能。
*   **関心の分離:** 複雑になりがちなタイムライン生成ロジックをカプセル化し、`avion-post` や `avion-user` などのサービスは本来の責務に集中できる。

タイムラインはユーザーが最も頻繁にアクセスする画面の一つであり、そのパフォーマンスとスケーラビリティはユーザー体験に直結するため、独立したサービスとして最適化する価値は非常に高い。

## Design Doc

後で書く

## 参考ドキュメント

*   [Avion アーキテクチャ概要](./../architecture.md)

## 製品原則

*   **関連性の高い情報:** ユーザーにとって関心のあるDrop（フォローしている人、同じサーバーの人など）を適切に届ける。
*   **新鮮な情報:** 新しいDropがタイムラインに迅速に反映されること。
*   **快適な閲覧体験:** 高速なレスポンスとスムーズなページネーションを提供する。

## やること/やらないこと

### やること

*   ホームタイムラインの生成と取得 (フォローしているユーザーのDropを時系列順に表示)
*   ローカルタイムラインの生成と取得 (自身が所属するサーバー内の公開Dropを時系列順に表示)
*   グローバルタイムライン (連合タイムライン) の生成と取得 (連合しているサーバーを含む公開Dropを時系列順に表示)
*   Redisを活用したタイムラインデータのキャッシュ (特にホームタイムライン)
*   ページネーション機能 (前方・後方への読み込み)
*   新しいDropが投稿された際のタイムライン更新 (Fan-out on write方式などを検討)
*   Server-Sent Events (SSE) によるタイムライン更新イベントの配信 (ホームタイムライン向け)

### やらないこと

*   **Dropデータの永続化:** Drop自体の保存は `avion-post` が担当する。`avion-timeline` はDropのIDリストなどをキャッシュとして保持する。
*   **ユーザーフォロー関係の管理:** フォロー情報は `avion-user` が管理する。`avion-timeline` はそれを参照する。
*   **複雑なランキングアルゴリズム (初期):** 初期リリースでは基本的に時系列順とする。いいね数やリポスト数に基づくランキングなどは将来的に検討。
*   **検索機能:** タイムライン内の検索は `avion-search` が担当する。
*   **WebSocket:** 双方向通信は現時点では不要なため実装しない。SSEを優先する。

## 対象ユーザ

*   Avion エンドユーザー (API Gateway経由)
*   Avion 開発者・運用者

## ユースケース

### ホームタイムライン表示

1.  ユーザーがAvionアプリを開き、ホームタイムラインを表示する。
2.  `avion-gateway` 経由で `avion-timeline` にホームタイムライン取得リクエストが送られる (認証JWTが必要)。
3.  `avion-timeline` はリクエスト元のユーザーIDに基づき、RedisキャッシュからホームタイムラインのDrop IDリストを取得する。
4.  キャッシュが存在しない、または古い場合は、`avion-user` からフォローリストを取得し、`avion-post` から該当ユーザーの最近のDropを取得してタイムラインを再構築し、キャッシュに保存する。
5.  取得したDrop IDリスト (または必要に応じて `avion-post` から取得したDrop詳細情報) を返す。
6.  フロントエンドは受け取った情報をもとにホームタイムラインを表示する。

6.  フロントエンドは受け取った情報をもとにホームタイムラインを表示する。
7.  (SSE) フロントエンドはホームタイムライン用のSSEエンドポイントに接続する。
8.  (SSE) 新しいDropがユーザーのホームタイムラインに追加されると、`avion-timeline` は接続中のSSEクライアントにイベント (例: 新しいDropのID) を送信する。
9.  (SSE) フロントエンドはイベントを受信し、タイムライン表示を更新する (例: 新しいDropをリストの先頭に追加)。

(UIモック: ホームタイムライン画面)

### ローカルタイムライン表示

1.  ユーザーがローカルタイムラインタブを選択する。
2.  `avion-gateway` 経由で `avion-timeline` にローカルタイムライン取得リクエストが送られる。
3.  `avion-timeline` はRedisキャッシュからローカルタイムラインのDrop IDリストを取得する。
4.  キャッシュが存在しない、または古い場合は、`avion-post` からサーバー内の最近の公開Dropを取得してタイムラインを再構築し、キャッシュに保存する。
5.  取得したDrop IDリストを返す。
6.  フロントエンドは受け取った情報をもとにローカルタイムラインを表示する。

(UIモック: ローカルタイムライン画面)

### グローバルタイムライン表示

1.  ユーザーがグローバルタイムラインタブを選択する。
2.  `avion-gateway` 経由で `avion-timeline` にグローバルタイムライン取得リクエストが送られる。
3.  `avion-timeline` はRedisキャッシュからグローバルタイムラインのDrop IDリストを取得する。
4.  キャッシュが存在しない、または古い場合は、`avion-post` および `avion-activitypub` (他サーバーからの受信分) から最近の公開Dropを取得してタイムラインを再構築し、キャッシュに保存する。
5.  取得したDrop IDリストを返す。
6.  フロントエンドは受け取った情報をもとにグローバルタイムラインを表示する。

(UIモック: グローバルタイムライン画面)

### タイムラインの更新 (新しいDropの反映)

1.  ユーザーAが新しいDropを作成する (`avion-post` が処理)。
2.  `avion-post` はDrop作成イベントを発行する (例: Redis Pub/Sub)。
3.  `avion-timeline` はイベントを受信する。
4.  Dropが公開であれば、ローカルタイムラインとグローバルタイムラインのキャッシュを更新する (例: 新しいDrop IDをリストの先頭に追加)。
5.  `avion-user` からユーザーAのフォロワーリストを取得する。
6.  各フォロワーのホームタイムラインキャッシュを更新する (Fan-out on write)。

## 機能要求

*   **タイムライン種別:** ホーム、ローカル、グローバルの3種類をサポートすること。
*   **順序:** 基本的に新しいDropが上に表示される時系列順であること。
*   **ページネーション:** `limit` (取得件数) と `since_id` (これより新しいものを取得), `max_id` (これより古いものを取得) のようなカーソルベースのページネーションをサポートすること。
*   **キャッシュ:** Redisを使用してタイムラインデータ (Drop IDリスト) をキャッシュし、高速な読み取りを実現すること。キャッシュの有効期限や更新戦略を適切に設定すること。
*   **更新:** 新しいDropが投稿された際に、関連するタイムラインキャッシュが準リアルタイムで更新される仕組みを持つこと (Fan-out on writeなど)。

## 技術的要求

### レイテンシ

*   タイムライン取得 (1ページあたり): 平均 200ms 以下 (キャッシュヒット時)
*   タイムライン更新 (新しいDrop反映): 非同期処理で許容されるが、ユーザーが体感する遅延は数秒以内を目指す。

### 可用性

*   タイムライン取得およびSSE接続エンドポイントは高可用性が求められる。Kubernetes上での運用を前提とし、複数レプリカによる冗長構成をとる。Redisクラスターなど、キャッシュ層の可用性も重要となる。

### スケーラビリティ

*   ユーザー数、フォロワー数、投稿数が増加しても、タイムラインの生成・取得性能が劣化しないように設計すること。特にホームタイムラインのFan-out処理のスケーラビリティが重要。
*   Redisのメモリ使用量と負荷を監視し、適切にスケールできるようにすること。

### データ整合性

*   キャッシュと永続化データ (PostgreSQL上のDropやフォロー情報) の間に不整合が生じる可能性を考慮し、必要に応じてキャッシュの再構築や整合性チェックの仕組みを設けること。
*   削除されたDropがタイムラインに残り続けないように、削除イベントを適切に処理し、必要であればSSEで削除イベントも通知することを検討する。

### その他技術要件

*   **ステートレス:** サービス自体は状態を持たず、水平スケールが可能であること。タイムラインキャッシュはRedisで管理する。SSE接続情報は別途管理が必要になる場合がある (Redis等を利用)。
*   **Observability:** OpenTelemetry SDKを導入し、トレース・メトリクス・ログを出力可能にすること。API Gatewayやイベント経由でトレースコンテキストを受け取り、他のサービスへの問い合わせ時にも伝播すること。
*   **リアルタイム更新:** Server-Sent Events (SSE) を実装し、ホームタイムラインの更新をクライアントにプッシュ通知する。

## 決まっていないこと

*   タイムラインキャッシュの具体的なデータ構造 (Redis Sorted Set, Listなど)
*   Fan-out on write の具体的な実装方法と、フォロワー数が多いユーザーへの対応策 (非同期ジョブキューなど)
*   SSE接続の管理方法とスケーラビリティ対策。
*   SSEで送信するイベントのフォーマット。
*   キャッシュ戦略の詳細 (有効期限、パージ方法)
*   ローカル/グローバルタイムラインの厳密な定義 (どの範囲の投稿を含めるか)
